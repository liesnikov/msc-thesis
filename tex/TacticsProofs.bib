
@article{appel2006tactics,
  title = {Tactics for Separation Logic},
  author = {Appel, Andrew W},
  year = {2006},
  file = {/home/buzzer/my-dir/personal/Dropbox/stuff/papers/Appel/2006/Appel - 2006 - Tactics for separation logic.pdf},
  journal = {INRIA Rocquencourt and Princeton University, Early Draft}
}

@inproceedings{boutinUsingReflectionBuild1997,
  title = {Using Reflection to Build Efficient and Certified Decision Procedures},
  booktitle = {Theoretical {{Aspects}} of {{Computer Software}}},
  author = {Boutin, Samuel},
  editor = {Abadi, Mart{\'i}n and Ito, Takayasu},
  year = {1997},
  pages = {515--529},
  publisher = {{Springer}},
  address = {{Berlin, Heidelberg}},
  doi = {10.1007/BFb0014565},
  abstract = {In this paper we explain how computational reflection can help build efficient certified decision procedure in reduction systems. We have developed a decision procedure on abelian rings in the Coq system but the approach we describe applies to all reduction systems that allow the definition of concrete types (or datatypes). We show that computational reflection is more efficient than an LCF-like approach to implement decision procedures in a reduction system. We discuss the concept of total reflection, which we have investigated in Coq using two facts: the extraction process available in Coq and the fact that the implementation language of the Coq system can be considered as a sublanguage of Coq. Total reflection is not yet implemented in Coq but we can test its performance as the extraction process is effective. Both reflection and total reflection are conservative extensions of the reduction system in which they are used. We also discuss performance and related approaches. In the paper,we assume basic knowledges of ML and proof-checkers.},
  file = {/home/buzzer/my-dir/personal/Dropbox/stuff/papers/Boutin/1997/Boutin - 1997 - Using reflection to build efficient and certified .pdf},
  isbn = {978-3-540-69530-1},
  keywords = {Computer Algebra System,Decision Procedure,Object Language,Order Theory,Reduction System},
  language = {en},
  series = {Lecture {{Notes}} in {{Computer Science}}}
}

@misc{chajedLtac2Tutorial,
  title = {An {{Ltac2}} Tutorial},
  author = {Chajed, Tej},
  abstract = {This tutorial aims to be pragmatic, but it is not specific to an application. The pragmatics of Ltac2 are likely to change, as the language becomes more usable. Picking an application and really trying to use Ltac2 for it is likely to uncover more tricks and bug reports necessary to make the language work.},
  howpublished = {https://github.com/tchajed/ltac2-tutorial/blob/master/src/ltac2\_tutorial.v},
  journal = {Github},
  type = {Source File}
}

@inproceedings{chlipalaBedrockStructuredProgramming2013,
  title = {The Bedrock Structured Programming System: Combining Generative Metaprogramming and Hoare Logic in an Extensible Program Verifier},
  shorttitle = {The Bedrock Structured Programming System},
  booktitle = {Proceedings of the 18th {{ACM SIGPLAN}} International Conference on {{Functional}} Programming},
  author = {Chlipala, Adam},
  year = {2013},
  month = sep,
  pages = {391--402},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/2500365.2500592},
  abstract = {We report on the design and implementation of an extensible programming language and its intrinsic support for formal verification. Our language is targeted at low-level programming of infrastructure like operating systems and runtime systems. It is based on a cross-platform core combining characteristics of assembly languages and compiler intermediate languages. From this foundation, we take literally the saying that C is a "macro assembly language": we introduce an expressive notion of certified low-level macros, sufficient to build up the usual features of C and beyond as macros with no special support in the core. Furthermore, our macros have integrated support for strongest postcondition calculation and verification condition generation, so that we can provide a high-productivity formal verification environment within Coq for programs composed from any combination of macros. Our macro interface is expressive enough to support features that low-level programs usually only access through external tools with no formal guarantees, such as declarative parsing or SQL-inspired querying. The abstraction level of these macros only imposes a compile-time cost, via the execution of functional Coq programs that compute programs in our intermediate language; but the run-time cost is not substantially greater than for more conventional C code. We describe our experiences constructing a full C-like language stack using macros, with some experiments on the verifiability and performance of individual programs running on that stack.},
  file = {/home/buzzer/my-dir/personal/Dropbox/stuff/papers/Chlipala/2013/Chlipala - 2013 - The bedrock structured programming system combini.pdf},
  isbn = {978-1-4503-2326-0},
  keywords = {functional programming,generative metaprogramming,interactive proof assistants,low-level programming languages},
  series = {{{ICFP}} '13}
}

@article{chlipalaMostlyautomatedVerificationLowlevel2011,
  title = {Mostly-Automated Verification of Low-Level Programs in Computational Separation Logic},
  author = {Chlipala, Adam},
  year = {2011},
  month = jun,
  volume = {46},
  pages = {234--245},
  issn = {0362-1340},
  doi = {10.1145/1993316.1993526},
  abstract = {Several recent projects have shown the feasibility of verifying low-level systems software. Verifications based on automated theorem-proving have omitted reasoning about first-class code pointers, which is critical for tasks like certifying implementations of threads and processes. Conversely, verifications that deal with first-class code pointers have featured long, complex, manual proofs. In this paper, we introduce the Bedrock framework, which supports mostly-automated proofs about programs with the full range of features needed to implement, e.g., language runtime systems. The heart of our approach is in mostly-automated discharge of verification conditions inspired by separation logic. Our take on separation logic is computational, in the sense that function specifications are usually written in terms of reference implementations in a purely functional language. Logical quantifiers are the most challenging feature for most automated verifiers; by relying on functional programs (written in the expressive language of the Coq proof assistant), we are able to avoid quantifiers almost entirely. This leads to some dramatic improvements compared to both past work in classical verification, which we compare against with implementations of data structures like binary search trees and hash tables; and past work in verified programming with code pointers, which we compare against with examples like function memoization and a cooperative threading library.},
  file = {/home/buzzer/.local/share/Zotero/storage/LFV7B44B/Chlipala - Mostly-Automated Veriﬁcation of Low-Level Programs.pdf},
  journal = {ACM SIGPLAN Notices},
  keywords = {functional programming,interactive proof assistants,low-level programming languages,separation logic},
  number = {6}
}

@inproceedings{claretLightweightProofReflection2013,
  title = {Lightweight Proof by Reflection Using a Posteriori Simulation of Effectful Computation},
  booktitle = {Interactive {{Theorem Proving}}},
  author = {Claret, Guillaume and Huesca, Lourdes del Carmen Gonzalez and {R{\'e}gis-Gianas}, Yann and Ziliani, Beta},
  year = {2013},
  month = jul,
  doi = {10/document},
  abstract = {Proof-by-reflection is a well-established technique that em- ploys decision procedures to reduce the size of proof-terms. Currently, decision procedures can be written either in Type Theory--in a purely functional way that also ensures termination-- or in an effectful program- ming language, where they are used as oracles for the certified checker. The first option offers strong correctness guarantees, while the second one permits more efficient implementations. We propose a novel technique for proof-by-reflection that marries, in Type Theory, an effectful language with (partial) proofs of correctness. The key to our approach is to use simulable monads, where a monad is simulable if, for all terminating reduction sequences in its equivalent effectful computational model, there exists a witness from which the same reduction may be simulated a posteriori by the monad. We encode several examples using simulable monads and demonstrate the advantages of the technique over previous approaches.},
  file = {/home/buzzer/my-dir/personal/Dropbox/stuff/papers/Claret et al/2013/Claret et al. - 2013 - Lightweight proof by reflection using a posteriori.pdf;/home/buzzer/.local/share/Zotero/storage/QB8922W7/hal-00870110.html},
  language = {en}
}

@article{harlandResourceDistributionBooleanConstraints2003,
  title = {Resource-{{Distribution}} via {{Boolean Constraints}}},
  author = {Harland, James and Pym, David},
  year = {2003},
  month = jan,
  volume = {4},
  pages = {56--90},
  issn = {1529-3785},
  doi = {10.1145/601775.601778},
  abstract = {We consider the problem of searching for proofs in sequential presentations of logics with multiplicative (or intensional) connectives. Specifically, we start with the multiplicative fragment of linear logic and extend, on the one hand, to linear logic with its additives and, on the other, to the additives of the logic of bunched implications (BI). We give an algebraic method for calculating the distribution of the side-formul\ae{} in multiplicative rules which allows the occurrence or non-occurrence of a formula on a branch of a proof to be determined once sufficient information is available. Each formula in the conclusion of such a rule is assigned a Boolean expression. As a search proceeds, a set of Boolean constraint equations is generated. We show that a solution to such a set of equations determines a proof corresponding to the given search. We explain a range of strategies, from the lazy to the eager, for solving sets of constraint equations. We indicate how to apply our methods systematically to large family of relevant systems.},
  file = {/home/buzzer/my-dir/personal/Dropbox/stuff/papers/Harland/undefined/Harland - Resource-distribution via Boolean Constraints.pdf;/home/buzzer/my-dir/personal/Dropbox/stuff/papers/Harland/undefined/Harland - Resource-distribution via Boolean Constraints2.pdf},
  journal = {ACM Trans. Comput. Logic},
  keywords = {Algebras,Boolean constraints,proof-search,relevant logics,sequent calculus,substructural logics},
  number = {1}
}

@techreport{jones1993composing,
  title = {Composing Monads},
  author = {Jones, Mark P and Duponcheel, Luc},
  year = {1993},
  institution = {{Technical Report YALEU/DCS/RR-1004, Department of Computer Science. Yale University, New Haven}}
}

@article{jungIrisGroundModular2018,
  title = {Iris from the Ground up: {{A}} Modular Foundation for Higher-Order Concurrent Separation Logic},
  shorttitle = {Iris from the Ground Up},
  author = {Jung, Ralf and Krebbers, Robbert and Jourdan, Jacques-Henri and Bizjak, Ale{\v s} and Birkedal, Lars and Dreyer, Derek},
  year = {2018},
  volume = {28},
  issn = {0956-7968, 1469-7653},
  doi = {10.1017/S0956796818000151},
  abstract = {Iris is a framework for higher-order concurrent separation logic, which has been implemented in the Coq proof assistant and deployed very effectively in a wide variety of verification projects. Iris was designed with the express goal of simplifying and consolidating the foundations of modern separation logics, but it has evolved over time, and the design and semantic foundations of Iris itself have yet to be fully written down and explained together properly in one place. Here, we attempt to fill this gap, presenting a reasonably complete picture of the latest version of Iris (version 3.1), from first principles and in one coherent narrative.},
  file = {/home/buzzer/my-dir/personal/Dropbox/stuff/papers/Jung et al/2018/Jung et al. - 2018 - Iris from the ground up A modular foundation for .pdf},
  journal = {Journal of Functional Programming},
  language = {en}
}

@article{kaiserMtac2TypedTactics2018a,
  title = {Mtac2: Typed Tactics for Backward Reasoning in {{Coq}}},
  shorttitle = {Mtac2},
  author = {Kaiser, Jan-Oliver and Ziliani, Beta and Krebbers, Robbert and {R{\'e}gis-Gianas}, Yann and Dreyer, Derek},
  year = {2018},
  month = jul,
  volume = {2},
  pages = {1--31},
  issn = {2475-1421, 2475-1421},
  doi = {10.1145/3236773},
  file = {/home/buzzer/my-dir/personal/Dropbox/stuff/papers/Kaiser et al/2018/Kaiser et al. - 2018 - Mtac2 typed tactics for backward reasoning in Coq2.pdf},
  journal = {Proceedings of the ACM on Programming Languages},
  language = {en},
  number = {ICFP}
}

@article{kiselyovBacktrackingInterleavingTerminating2005,
  title = {Backtracking, Interleaving, and Terminating Monad Transformers: (Functional Pearl)},
  shorttitle = {Backtracking, Interleaving, and Terminating Monad Transformers},
  author = {Kiselyov, Oleg and Shan, Chung-chieh and Friedman, Daniel P. and Sabry, Amr},
  year = {2005},
  month = sep,
  volume = {40},
  pages = {192--203},
  issn = {0362-1340},
  doi = {10.1145/1090189.1086390},
  abstract = {We design and implement a library for adding backtracking computations to any Haskell monad. Inspired by logic programming, our library provides, in addition to the operations required by the MonadPlus interface, constructs for fair disjunctions, fair conjunctions, conditionals, pruning, and an expressive top-level interface. Implementing these additional constructs is easy in models of backtracking based on streams, but not known to be possible in continuation-based models. We show that all these additional constructs can be generically and monadically realized using a single primitive msplit. We present two implementations of the library: one using success and failure continuations; and the other using control operators for manipulating delimited continuations.},
  file = {/home/buzzer/my-dir/personal/Dropbox/stuff/papers/Kiselyov et al/2005/Kiselyov et al. - 2005 - Backtracking, interleaving, and terminating monad .pdf},
  journal = {ACM SIGPLAN Notices},
  keywords = {continuations,control delimiters,Haskell,logic programming,Prolog,streams},
  number = {9}
}

@article{krebbersInteractiveProofsHigherorder2017,
  title = {Interactive Proofs in Higher-Order Concurrent Separation Logic},
  author = {Krebbers, Robbert and Lars, Birkedal and Timany, Amin},
  year = {2017},
  pages = {205--217},
  file = {/home/buzzer/my-dir/personal/Dropbox/stuff/papers/Krebbers et al/2017/Krebbers et al. - 2017 - Interactive proofs in higher-order concurrent sepa.pdf},
  journal = {Proceedings of the 44th ACM SIGPLAN Symposium on Principles of Programming Languages}
}

@article{krebbersMoSeLGeneralExtensible2018,
  title = {{{MoSeL}}: A General, Extensible Modal Framework for Interactive Proofs in Separation Logic},
  shorttitle = {{{MoSeL}}},
  author = {Krebbers, Robbert and Jourdan, Jacques-Henri and Jung, Ralf and Tassarotti, Joseph and Kaiser, Jan-Oliver and Timany, Amin and Chargu{\'e}raud, Arthur and Dreyer, Derek},
  year = {2018},
  month = jul,
  volume = {2},
  pages = {1--30},
  issn = {24751421},
  doi = {10.1145/3236772},
  file = {/home/buzzer/my-dir/personal/Dropbox/stuff/papers/Krebbers et al/2018/Krebbers et al. - 2018 - MoSeL a general, extensible modal framework for i.pdf},
  journal = {Proceedings of the ACM on Programming Languages},
  language = {en},
  number = {ICFP}
}

@misc{ListTDoneRight,
  title = {{{ListT}} Done Right - {{HaskellWiki}}},
  abstract = {The Haskell hierarchical libraries implement a ListT monad transformer. There are, however, some problems with that implementation.     ListT imposes unnecessary strictness.     ListT isn't really a monad transformer, ie. ListT m isn't always a monad for a monad m. See the \#Examples below for demonstrations of these problems.},
  file = {/home/buzzer/.local/share/Zotero/storage/6JJBPKFA/ListT_done_right.html},
  howpublished = {https://wiki.haskell.org/ListT\_done\_right},
  journal = {HaskellWiki},
  type = {Wiki}
}

@inproceedings{malechaExtensibleEfficientAutomation2016,
  title = {Extensible and {{Efficient Automation Through Reflective Tactics}}},
  booktitle = {Programming {{Languages}} and {{Systems}}},
  author = {Malecha, Gregory and Bengtson, Jesper},
  editor = {Thiemann, Peter},
  year = {2016},
  pages = {532--559},
  publisher = {{Springer}},
  address = {{Berlin, Heidelberg}},
  doi = {10.1007/978-3-662-49498-1_21},
  abstract = {Foundational proof assistants simultaneously offer both expressive logics and strong guarantees. The price they pay for this flexibility is often the need to build and check explicit proof objects which can be expensive. In this work we develop a collection of techniques for building reflective automation, where proofs are witnessed by verified decision procedures rather than verbose proof objects. Our techniques center around a verified domain specific language for proving, {$\mathsl{t}\mathsl{a}\mathsl{c}$}Rtac\textbackslash mathcal \{R\}\_\{tac\}, written in Gallina, Coq's logic. The design of tactics makes it easy to combine them into higher-level automation that can be proved sound in a mostly automated way. Furthermore, unlike traditional uses of reflection, {$\mathsl{t}\mathsl{a}\mathsl{c}$}Rtac\textbackslash mathcal \{R\}\_\{tac\} tactics are independent of the underlying problem domain, which allows them to be re-tasked to automate new problems with very little effort. We demonstrate the usability of {$\mathsl{t}\mathsl{a}\mathsl{c}$}Rtac\textbackslash mathcal \{R\}\_\{tac\} through several case studies demonstrating orders of magnitude speedups for relatively little engineering work.},
  file = {/home/buzzer/my-dir/personal/Dropbox/stuff/papers/Malecha_Bengtson/2016/Malecha and Bengtson - 2016 - Extensible and Efficient Automation Through Reflec.pdf},
  isbn = {978-3-662-49498-1},
  keywords = {Automatic Reflection,Objective Proof,Proof Assistant,Reﬂective Tactics,Unification Variables},
  language = {en},
  series = {Lecture {{Notes}} in {{Computer Science}}}
}

@incollection{mccreightPracticalTacticsSeparation2009,
  title = {Practical {{Tactics}} for {{Separation Logic}}},
  booktitle = {Theorem {{Proving}} in {{Higher Order Logics}}},
  author = {McCreight, Andrew},
  editor = {Berghofer, Stefan and Nipkow, Tobias and Urban, Christian and Wenzel, Makarius},
  year = {2009},
  volume = {5674},
  pages = {343--358},
  publisher = {{Springer Berlin Heidelberg}},
  address = {{Berlin, Heidelberg}},
  doi = {10.1007/978-3-642-03359-9_24},
  abstract = {We present a comprehensive set of tactics that make it practical to use separation logic in a proof assistant. These tactics enable the verification of partial correctness properties of complex pointer-intensive programs. Our goal is to make separation logic as easy to use as the standard logic of a proof assistant. We have developed tactics for the simplification, rearranging, splitting, matching and rewriting of separation logic assertions as well as the discharging of a program verification condition using a separation logic description of the machine state. We have implemented our tactics in the Coq proof assistant, applying them to a deep embedding of Cminor, a C-like intermediate language used by Leroy's verified CompCert compiler. We have used our tactics to verify the safety and completeness of a Cheney copying garbage collector written in Cminor. Our ideas should be applicable to other substructural logics and imperative languages.},
  file = {/home/buzzer/my-dir/personal/Dropbox/stuff/papers/McCreight/2009/McCreight - 2009 - Practical Tactics for Separation Logic.pdf},
  isbn = {978-3-642-03358-2 978-3-642-03359-9},
  language = {en}
}

@incollection{ohearnLocalReasoningPrograms2001,
  title = {Local {{Reasoning}} about {{Programs}} That {{Alter Data Structures}}},
  booktitle = {Computer {{Science Logic}}},
  author = {O'Hearn, Peter and Reynolds, John and Yang, Hongseok},
  editor = {Goos, Gerhard and Hartmanis, Juris and {van Leeuwen}, Jan and Fribourg, Laurent},
  year = {2001},
  volume = {2142},
  pages = {1--19},
  publisher = {{Springer Berlin Heidelberg}},
  address = {{Berlin, Heidelberg}},
  doi = {10.1007/3-540-44802-0_1},
  abstract = {We describe an extension of Hoare's logic for reasoning about programs that alter data structures. We consider a low-level storage model based on a heap with associated lookup, update, allocation and deallocation operations, and unrestricted address arithmetic. The assertion language is based on a possible worlds model of the logic of bunched implications, and includes spatial conjunction and implication connectives alongside those of classical logic. Heap operations are axiomatized using what we call the ``small axioms'', each of which mentions only those cells accessed by a particular command. Through these and a number of examples we show that the formalism supports local reasoning: A specification and proof can concentrate on only those cells in memory that a program accesses.},
  file = {/home/buzzer/my-dir/personal/Dropbox/stuff/papers/O’Hearn et al/2001/O’Hearn et al. - 2001 - Local Reasoning about Programs that Alter Data Str.pdf},
  isbn = {978-3-540-42554-0 978-3-540-44802-0},
  language = {en}
}

@misc{pedrotCoqHoTTminuteTickingClockwork2016,
  title = {{{CoqHoTT}}-Minute : {{Ticking}} like a {{Clockwork}}: The {{New Coq Tactics}}},
  author = {P{\'e}drot, Pierre-Marie},
  year = {2016},
  month = feb,
  abstract = {This post describes the new tactic engine designed by Arnaud Spiwack which has replaced the old implementation beginning from Coq 8.5. To replace this work in its context, we first recall the history of tactics in Coq, both from the point of view of the user and the developer. There will be more OCaml code than Coq code, so please bear with me. Hopefully this will clarify things up for people outside of the c\'enacle of Coq developers, and provide hindsights into the current design choices.},
  file = {/home/buzzer/.local/share/Zotero/storage/L9QMVCYB/coq-tactic-engine.html},
  journal = {CoqHoTT-minute},
  language = {en}
}

@misc{pedrotLtac2016,
  title = {Towards {{Ltac}} 2.0},
  author = {P{\'e}drot, Pierre-Marie},
  year = {2016},
  month = jun,
  file = {/home/buzzer/.local/share/Zotero/storage/BILXA737/deepspec-06-16.pdf}
}

@inproceedings{pedrotLtac2TacticalWarfare2019,
  title = {Ltac2: {{Tactical Warfare}}},
  booktitle = {The {{Fifth International Workshop}} on {{Coq}} for {{Programming Languages}} /},
  author = {P{\'e}drot, Pierre-Marie},
  year = {2019},
  pages = {3},
  address = {{Cascais, Portugal}},
  abstract = {We present Ltac2, a proposal for the replacement of the Ltac tactic language that is shipped with Coq as the default interface to build up proofs interactively. Ltac2 is primarily motivated by two antagonistic desires, namely extending the expressivity and regularity of the historical tactic language of Coq while maintaining a strong backward compatibility. We thereafter give a bird's eye view of the features and semantics of the current state of Ltac2.},
  file = {/home/buzzer/my-dir/personal/Dropbox/stuff/papers/Pédrot/2019/Pédrot - 2019 - Ltac2 Tactical Warfare.pdf},
  language = {en}
}

@misc{pedrotLtacInternals2016,
  title = {Ltac {{Internals}}},
  author = {P{\'e}drot, Pierre-Marie},
  year = {2016},
  month = mar,
  file = {/home/buzzer/my-dir/personal/Dropbox/stuff/papers/Pédrot/2016/Pédrot - 2016 - Ltac Internals.pdf},
  language = {en}
}

@book{pymSemanticsProofTheory2002a,
  title = {The {{Semantics}} and {{Proof Theory}} of the {{Logic}} of {{Bunched Implications}}},
  author = {Pym, David J.},
  editor = {Gabbay, Dov M. and Barwise, Jon},
  year = {2002},
  volume = {26},
  publisher = {{Springer Netherlands}},
  address = {{Dordrecht}},
  doi = {10.1007/978-94-017-0091-7},
  file = {/home/buzzer/my-dir/personal/Dropbox/stuff/papers/Pym/2002/Pym - 2002 - The Semantics and Proof Theory of the Logic of Bun.pdf},
  isbn = {978-90-481-6072-3 978-94-017-0091-7},
  series = {Applied {{Logic Series}}}
}

@inproceedings{reynoldsSeparationLogicLogic2002,
  title = {Separation Logic: A Logic for Shared Mutable Data Structures},
  shorttitle = {Separation Logic},
  booktitle = {Proceedings 17th {{Annual IEEE Symposium}} on {{Logic}} in {{Computer Science}}},
  author = {Reynolds, J.C.},
  year = {2002},
  pages = {55--74},
  publisher = {{IEEE Comput. Soc}},
  address = {{Copenhagen, Denmark}},
  doi = {10.1109/LICS.2002.1029817},
  abstract = {In joint work with Peter O'Hearn and others, based on early ideas of Burstall, we have developed an extension of Hoare logic that permits reasoning about low-level imperative programs that use shared mutable data structure.},
  file = {/home/buzzer/my-dir/personal/Dropbox/stuff/papers/Reynolds/2002/Reynolds - 2002 - Separation logic a logic for shared mutable data .pdf},
  isbn = {978-0-7695-1483-3},
  language = {en}
}

@inproceedings{spiwackAbstractTypeConstructing2010,
  title = {An Abstract Type for Constructing Tactics in {{Coq}}},
  booktitle = {Proof {{Search}} in {{Type Theory}}},
  author = {Spiwack, Arnaud},
  year = {2010},
  month = jul,
  abstract = {The Coq proof assistant is a large development, a lot of which happens to be more or less dependent on the type of tactics. To be able to perform tweaks in this type more easily in the future, we propose an API for building tactics which doesn't need to expose the type of tactics and yet has a fairly small amount of primitives. This API accompanies an entirely new implementation of the core tactic engine of Coq which aims at handling more gracefully existential variables (aka. metavariables) in proofs - like in more recent proof assistants like Matita and Agda2. We shall, then, leverage this newly acquired independence of the concrete type of tactics from the API to add backtracking abilities.},
  file = {/home/buzzer/my-dir/personal/Dropbox/stuff/papers/Spiwack/2010/Spiwack - 2010 - An abstract type for constructing tactics in Coq.pdf},
  language = {en}
}

@misc{thecoqdevelopmentteamCoqProofAssistant2020,
  title = {The {{Coq Proof Assistant}}, Version 8.12.0},
  author = {{The Coq Development Team}},
  year = {2020},
  month = jul,
  doi = {10.5281/zenodo.4021912},
  file = {/home/buzzer/my-dir/personal/Dropbox/stuff/papers/The Coq Development Team/2020/The Coq Development Team - 2020 - The Coq Proof Assistant, version 8.12.0.pdf},
  howpublished = {Zenodo},
  keywords = {formal proofs,mathematical software,proof assistant},
  language = {eng}
}

@inproceedings{zilianiMtacMonadTyped2013,
  title = {Mtac: A Monad for Typed Tactic Programming in {{Coq}}},
  shorttitle = {Mtac},
  booktitle = {Proceedings of the 18th {{ACM SIGPLAN}} International Conference on {{Functional}} Programming - {{ICFP}} '13},
  author = {Ziliani, Beta and Dreyer, Derek and Krishnaswami, Neelakantan R. and Nanevski, Aleksandar and Vafeiadis, Viktor},
  year = {2013},
  pages = {87},
  publisher = {{ACM Press}},
  address = {{Boston, Massachusetts, USA}},
  doi = {10.1145/2500365.2500579},
  abstract = {Effective support for custom proof automation is essential for largescale interactive proof development. However, existing languages for automation via tactics either (a) provide no way to specify the behavior of tactics within the base logic of the accompanying theorem prover, or (b) rely on advanced type-theoretic machinery that is not easily integrated into established theorem provers.},
  file = {/home/buzzer/my-dir/personal/Dropbox/stuff/papers/Ziliani et al/2013/Ziliani et al. - 2013 - Mtac a monad for typed tactic programming in Coq.pdf},
  isbn = {978-1-4503-2326-0},
  language = {en}
}


