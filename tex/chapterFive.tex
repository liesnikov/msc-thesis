\chapter{iMatch}
\label{chap:imatch}


Ltac has a tactical for matching on the current proof state, which looks as follows:
\begin{coq}
match goal with
| [a:P, b:Q |- P] => exact a
end
\end{coq}
In this example we are matching the context that's supposed to contain at least two assumptions: \coqe{P} and \coqe{Q}.
We also require the goal to be exactly \coqe{Q} and then close the proof with the first assumption matched in the context.

Iris Proof Mode doesn't use Coq contexts, since they don't track hypothesis usage, which can result in resources being used multiple times or thrown away.
Instead, IPM stores whole proof state in the goal, thus limiting usability \coqe{match goal} significantly.

\coqe{iMatch} is precisely a substitute for \coqe{match goal} for Iris Proof Mode.

\section{Motivation/examples}

While one of the most useful examples of usage for \coqe{iMatch} would be a solver for separation logic, we are going to cover it in a later chapter~\ref{chap:solver}.
Let us then take a simpler and more intuitive example here.
Suppose we want to extend \coqe{iAssumption} tactic so that it also applies suitable wands it can find in the context.

Let's call this new tactic \coqe{iAssumption'}.
This would allow us to discharge goals like the following with \coqe{repeat iAssumption'}.\\

\begin{minipage}{\linewidth}
\texttt{P, Q : PROP\\
---------------------------------------\\
"q" : Q\\
"p" : Q $\wand$ P\\
---------------------------------------*\\
P
}
\end{minipage}


\begin{minipage}{\linewidth}
\begin{coq}
Ltac2 iAssumption' :=
  iMatch! goal with
  | [a : ?e -* ?f |- ?f] => iApply a
  | [a : ?e |- ?e] => iExact a
  end.
\end{coq}
\end{minipage}

\coqe{iAssumption'} will succed in matching proof state in two cases:
\begin{enumerate}
\item if context (either intuitionistic or spatial) contains a wand with conclusion that is the same as the goal
\item if context (again, either of them) contains an assumption which matches the goal exactly
\end{enumerate}

If neither of those conditions is true, it's going to fail with a {\color{red} \texttt{Match\_failure}} exception.

A notable thing with this tactic is not just readability, assuming one is familiar with \coqe{match goal} construct.
It's also conciseness -- a similar tactic in pure Ltac1 code has to search for a fitting hypothesis in both contexts manually, which in the current Iris Proof Mode implementation is taking 30 lines of code.

\section{Implemented thing}

Naturally, complexity that Ltac1 code has to deal with isn't going anywhere.
Rather, it is abstracted into \coqe{iMatch}.
In this section we describe how exactly \coqe{iMatch} differs from the original \coqe{match goal} and discuss implementation details.

\subsection{Comparison with \texttt{match goal}}

While we try to preserve \coqe{match goal} behavior for user convenience, there are several notable differences:
\begin{itemize}
\item As noted above, Iris Proof Mode state has several contexts (three, namely), compared to regular Coq proof state.
  We give provide an ability to access all of them.
  \begin{figure}[H]
  \begin{coq}
       iMatch! goal with
       | [a:P, b:Q |- _] => ...
       | [a:P, _:$\Vert$, b:Q |- _] => ...
       | [x: nat, _:$\Vert$, a:P, _:$\Vert$, b:Q |- _] => ...
       end
   \end{coq}
   \caption{Context matching example}
   \label{fig:example:contex_matching}
  \end{figure}
  The first branch of the example~\ref{fig:example:contex_matching} matches two hypotheses, regardless of where they come from, be it intuitionistic or spatial context.\\
  The second branch introduces a separator, \coqe{_:$\Vert$}, which makes \coqe{iMatch} consider only intuitionistic hypotheses for the patterns on the left of it (\coqe{a:P}) and only spatial ones for the patterns on the right (\coqe{b:Q}).\\
  The third branch introduces yet another separator, so that patterns to the left of the first \coqe{_:$\Vert$} are matched from the Coq context, and successive patterns are matched from intuitionistic and spatial hypotheses respectively.

\item \coqe{iMatch} supports entailemnts with constraints, as introduced in the previous chapter~\ref{chap:postponed_splitting}.
\begin{coq}
iMatch! goal with
| [a:P |- _] => ...
| [a:<?>P |- _] => ...
| [a:<?c>P |- _] => ...
| [a:<true>P |- _ ] => ...
\end{coq}
  The first two options are equivalent and match only hypotheses with constraints which don't evaluate to \false\\
  The third one binds the constraint to \coqe{c} in case user wants to minuplate it or force its unification with either $\true$ or $\false$ manually.\\
  The last one only matches hypotheses which are guaranteed to be present in the context, as opposed to ones which might or might not be in this branch of the proof after splitting the context.
  This generalizes to arbitrary constraints, so a user can also write \coqe{<?c1 \& ?c2>}.
  Though where such generality might be useful is not entirely clear.
\item \coqe{match goal} patterns allow user to match one hypothesis only once, which is a sensible default.
  However, in Iris Proof Mode a user has to deal with intuitionistic contexts.
  These are defined to contain resources, which are both affine and persistent.
  The latter allows the user to duplicate them.\\
  Thus, we provide a Coq flag to allow them to match the same hypothesis from persistent context multiple times and duplicate matched resources on the fly.
  \todo{implement}

\begin{minipage}{\linewidth}
\texttt{P, Q : PROP\\
---------------------------------------\\
q : P $\wedge$ Q\\
---------------------------------------$\intuit$\\
---------------------------------------*\\
P * Q
}
\end{minipage}

\begin{coq}
iMatch goal with
| [a : P /\ _, b : _ /\ Q |- _] => ...
end
\end{coq}
\end{itemize}


\subsection{Implementation details}
\label{subsec:implementation_details}

Ltac2 computation model includes an ambient monad, which is a state, list (non-binary choice) and captures exceptions simultaneously.
However, for a high-level description of implementation having only a list monad \coqe{M} suffices.
To this end, we take \coqe{(Control.zero : forall a, M a)} to be an empty list.
And \coqe{(Control.plus : forall a, M a -> M a -> M a)} to be \coqe{append} operator for lists.

For simplicity, let's also assume that patterns can't contain contexts, e.g. \coqe{pattern:(context a [I])}.
They don't add much in terms of conceptual complexity and the only change would be to pass results of their matches around too.

From Ltac2 we take a function \coqe{Pattern.match}, \coqe{match! goal} and notation (a scope, in Ltac2 terms) for goal pattern-matching.
The latter allows us to reuse the same syntax as \coqe{match! goal}:
\begin{coq}
Ltac2 Notation "iMatch!" "goal" "with" m(goal_matching) "end" :=
  i_match_one_goal m.
\end{coq}
This provides \coqe{i_match_one_goal} with a list of branch-matching tuples.
Every such pattern consists of a list of patterns for hypotheses, a pattern for the goal and a substitution function that computes value of the right-hand side of the branch when provided with values that patterns bind.

\begin{coq}
Ltac2 i_match_goal pats :=
  let rec interp ps := match ps with
  | [] => Control.zero
  | ph :: pt =>
    let (pat, f) := ph in
    let (phyps, pconcl) := pat in
    let rest := fun () => interp pt in
    let cur := fun () =>
      let (hids, subst) := i_match_patterns_goal phyps pconcl in
      f hids subst
    in Control.plus cur rest
  end in
  interp pats.
\end{coq}

After taking apart one branch \coqe{ph}, we bind \coqe{rest} to the rest of the computation (matches other branches) and compute returned value on this branch.

And since \coqe{f} is given to us by the Ltac2 machinery, we are only left with \coqe{i_match_patterns_goal} to worry about.

We will describe the rest of the implementation on a higher level now.

Inside \coqe{i_match_patterns_goal}, current proof state is matched and Iris Proof Mode contexts and goal are extracted from it.
We then compute all possible pairings of hypotheses and patterns with help of \coqe{Pattern.match} and return them as alternatives inside monad \coqe{M}.
We also match current IPM goal with goal pattern \coqe{pconcl}, take a direct product of these two monadic values and merge substitution maps.
Essentially, if \coqe{i_match_patterns_goal} returns a non-zero result, the last part of the computation above takes form of
\todo{rewrite this}
\begin{coq}
let (hids, subst) := Control.plus (h,s) foo in
f hids subst
\end{coq}
which evaluates to
\begin{coq}
Control.plus
  (let (hids, subst) := (h,s) in
    f hids subst)
  (let (hids, subst) := foo in
   f hids subst)
\end{coq}

Which from a user perspective simply means that there might be several alternative bindings of hypotheses to identifers inside the match.

In case \coqe{i_match_patterns_goal} can't match current proof state with this branch's patterns (\coqe{i_match_patterns_goal phyps pconcl}) or branch right-hand side fails (\coqe{f hids subst}), \coqe{cur} will be set to \coqe{fun () => Control.zero}.
This results in a following redex:
\begin{coq}
let cur := fun () => Control.zero
in Control.plus cur rest
\end{coq}
Which in its own turn evaluates to \coqe{rest}, so switching to a different branch from a user perspective.

However, there is a limitation to this implementation.
With current API it's impossible to implement non-linear patterns.
Which, for example, renders our previous implementation of \coqe{iAssumption'} incorrect.

Instead, it's possible to not require hypotheses to match the goal in any way and simply try applying each of them.
This degrades performance, but keeps the conciseness.
\begin{minipage}{\linewidth}
\begin{coq}
Ltac2 iAssumption'' :=
  iMatch! goal with
  | [a : ?e -* ?f |- _] => iApply a
  | [a : ?e |- _] => iExact a
  end.
\end{coq}
\end{minipage}

\section{Possible semantics and tradeoffs}

While it might seem like iMatch is mostly about pattern-matching, there are several major design decisions to make that aren't related to pattern-matching at all and are mostly about backtracking.

It might be tempting to think about iMatch simply selecting the right hypothesis when a user wants it to, this isn't exactly what's happening.
In reality Ltac, Ltac2 implementation, and ours, matches patterns will all fitting hypotheses sequentially, starting with the first one.

Which, intuitively, would make one think that if there are two hypotheses: \coqe{H1:P}, \coqe{H2:Q}, only one of the following two snippets would succeed.
\begin{coq}
  iMatch! goal with
  | [h1:P, h2:_ |- _ ] => ...
  end
\end{coq}
\begin{coq}
  iMatch! goal with
  | [h2:_, h1:P |- _ ] => ...
  end
\end{coq}

But while the first one goes through immediately, the second one will only succeed ``on a second attempt'', via backtracking.

%The code will initially match \coqe{h2} with \coqe{H1}, and then, finding nothing to match \coqe{h1} with, backtrack to find a different hypothesis for \coqe{h2}.
%Succeeding, of course, with \coqe{H2:Q} and then matching \coqe{h1} with the only other hypothesis available --  \coqe{H1:P}.

Another example, which showcases the same idea and utilizes \coqe{iAssumption''} is the following: assuming that logic is affine and instead of one, there are two wands available:\\
\begin{minipage}{\linewidth}
\texttt{P, Q, R : PROP\\
---------------------------------------\\
"q" : Q\\
"r" : Q $\wand$ R\\
"p" : Q $\wand$ P\\
--------------------------------------$\ast$\\
P
}
\end{minipage}

the composite tactic \coqe{do 2 iAssumption''} would still work.

%This is also achieved via backtracking.
Assuming that we are unlucky and \coqe{r} indeed comes earlier in the list of hypothesis than \coqe{p}, it will be the first one iMatch considers.
However, while the initial binding will succeed, applying this wand to the current goal won't, unless the conclusion of the wand matches the goal.
Which means that code will backtrack and bind the next fitting hypothesis -- \coqe{p}.
For which the application would succeed.

The difference between the two examples is that the first one showed backtracking over matches inside the pattern, while the second one -- over the tactics on the right-hand side of the match.

\subsection{Backtracking over matches: iLazyMatch and iMultiMatch}

The variant of iMatch which doesn't backtrack on the tactics is called iLazyMatch.
It still involves backtracking in the implementation, since hypothesis selection is done sequentially.
But if the binding was successful, failure of the tactic provided by the user on the branch won't cause a rollback.

At the same time, both iMatch and iLazyMatch don't backtrack if tactics after the match fail.
Meaning that they erase backtracking points, inside iMatch as soon as it succeeds.

Consider the following proof state:

\texttt{
P, Q, R : PROP\\
---------------------------------------\\
"q" : Q\\
"r" : R $\wand$ P\\
"p" : Q $\wand$ P\\
--------------------------------------$\ast$\\
P
}

With the current implementation of \coqe{iAssumption''}, \coqe{do 2 iAssumption''} will fail, since \coqe{r} is possible to apply to the current goal, there is no resource to provide the wand with after it has been applied.

However, if expose backtracking points after the match, failures in the later tactics (second \coqe{iAssumption''} in our example), will cause it to backtrack and
to choose a different hypothesis to apply, if available.
This variant is called \coqe{iMultiMatch} and the name is literally the only change it's necessary to make to the definition of \coqe{iAssumption''}.

In terms of implementation of \coqe{iMatch}, erasure of backtracking points is precisely what happens:
In terms of section~\ref{subsec:implementation_details}, \coqe{i_match_one_goal p := Control.once (i_match_goal p)}.

\subsection{Backtracking over branches}

Backtracking to a different branch happens in two cases, though second one is really visible to the user.

The first one is more of implementation detail and morally is simply ``right branch selection'' based on the pattern.
Implementations would try to match all branches linearly and will switch branches only when encountering an impossible pattern.
The reason we stress this here is that implementation-wise this relies on the same \coqe{Control.plus} machinery as other things here.

The second one is a bit more interesting as this is really the same behavior that differentiates iMatch from iLazyMatch, which we covered above.
\todo{More explanation here?}

\subsection{Backtracking over name binding}

The last place where backtracking appears is name conflict resolution.
Take the following snippet:

\begin{coq}
iMatch! goal with
| [a : ?e -* ?f, b : ?e |- _] => ...
end.
\end{coq}

It is non-linear in variable \coqe{e}, which is resolved in the following way:
Since the implementation is still matching hypotheses in a linear way, it first matches wand \coqe{a} with type \coqe{Q -* P}.
Thus producing binders \coqe{e $\mapsto$ Q} and \coqe{f $\mapsto$ P}.
When it tries to match the second hypothesis, it doesn't yet have any restrictions, so it will match anything for b, not necessarily \coqe{Q}.
But afterwards it will resolve name conflicts, checking whether constrs binded to the same names are convertible.

This feature isn't yet implemented in iMatch due to Ltac2 limitations.

\section{Ltac2 features missing}

More thorough handling of patterns.
\begin{itemize}
\item Pattern quotations (\coqe{pattern:(_)} as with \coqe{constr:(1)}).
\item For non-linear patterns we need at least pattern antiquotation.
\item To detect wildcards in a nice way it would be good to have \coqe{Pattern.Unsafe}.
\end{itemize}

\todo{more, with examples}
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "thesis"
%%% TeX-parse-self: t
%%% TeX-auto-save: t
%%% reftex-cite-format: 'natbib
%%% reftex-default-bibliography: ("/home/buzzer/my-dir/ed/uni/saar/prjcts/iris/npm/tex/TacticsProofs.bib")
%%% End: