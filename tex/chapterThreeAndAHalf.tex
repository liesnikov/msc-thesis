\chapter{Reimplementing MoSeL in Ltac2}
\label{chap:ltac2-tactics-mosel}

In this chapter we present our reimplementation of MoSeL from Ltac1 to Ltac2.
As evident from figure~\ref{fig:ipm-diagram}, we only have to alter the topmost layer of the implementation -- the rest will stay exactly the same.
In the reimplementation we follow both the ideas and the design of MoSeL closely to ensure backwards compatibility and correct usage of existing infrastructure.

We are going to describe some details from the new Ltac2 part of MoSeL and then share our experiences with translation of existing Ltac1 code to Ltac2.

\section{Ltac2 layer of MoSeL}

The translation is mostly mechanical and serves as a platform for features developed in the following chapters.
And as the difference is mainly syntactical, we are going to simply show two examples.
First the snippet from \coqe{i_exact}, for which we have a comparison in the previous chapter (figure~\ref{fig:ltac1-iassumption}).
And then a simplified implementation of \coqe{iAssumption} in Ltac2.

As Ltac2 replicates many of Ltac1 tactics, we can simply swap tactics for their Ltac2 counterparts.
In the \coqe{i_exact} the only visible changes are the fact that internal tactics (\coqe{iSolveTC} and others) became Ltac2 functions, that now require an explicit call to be invoked and a different notation for goal dispatch.
\begin{figure}[H]
\begin{coq}
refine '(tac_assumption _ \$j false \$pp _ _ _ _) >
              [ pm_reflexivity () (* for the lookup *)
              | i_solve_tc () (* perform type class search for FromAssumption*)
              | pm_reduce (); (* evaluate env_delete and if-branch *)
                i_solve_tc ()]
\end{coq}
  \caption{Part of Ltac2 implementation of iExact}
  \label{fig:iexact-ltac2}
\end{figure}

For \coqe{iAssumption} the idea is that the user doesn't provide explicit identifier of the resource they have in mind.
Instead, the tactic is supposed to find it on its own.

Simply asserting the existence of such an identifier in a Coq lemma doesn't solve anything, since we clearly can not prove existence of the relevant resource in general.
Hence the universally quantified identifier in the definition of the Coq lemma~\ref{fig:tac-assumption}.
To solve the problem with providing the identifier for lemma we go through all elements of the environment in an Ltac2 function and try to apply the lemma with each one.

\begin{figure}
\begin{coq}
Ltac2 i_assumption () :=
  let rec find (p : coq_bool) (g : ipm_env) (q : ipm_prop) :=
      lazy_match! g with
      | Esnoc ?gg ?j ?pp =>
        first [ refine '(tac_assumption _ \$j \$p \$pp _ _ _ _) >
                [ pm_reflexivity () (* for the lookup *)
                | i_solve_tc () (* perform type class search for FromAssumption*)
                | pm_reduce (); (* evaluate env_delete and if-branch *)
                  i_solve_tc ()]
              | find p gg q]
      end
  in
  lazy_match! goal with
  | [|- envs_entails (Envs ?gp ?gs _) ?q] =>
     first [ find '(true) gp q
           | find '(false) gs q
           | i_assumption_coq ()
           | Control.zero (Iriception (of_string "no assumption matching " ++
                                       of_constr q ++
                                       of_string " was found"))]
  end.
\end{coq}
\caption{\coqe{i_assumption} definition}
\label{fig:i-assumption-def}
\end{figure}

The listing is in figure~\ref{fig:i-assumption-def}.
Since there are two contexts to go through, we factor out recursion into a \coqe{find} function, which takes a Boolean flag \coqe{p} to tell apart spatial and intuitionistic context, a context \coqe{g} and a proposition \coqe{q}.
We then use exactly the same code as in \coqe{i_exact}, except this time the choice of the context and proposition is done mechanically by the \coqe{find} function.

The only part which wasn't described so far is \coqe{i_assumption_coq ()}.
This is an example of tactics composition -- \coqe{i_assumption_coq} is applying a different lemma from \coqe{tac_assumption}, which tries to find an assumption of shape \(\Vdash Q\) in the Coq context instead of MoSeL context.

This example also showcases some error handling in the last case, if none of the cases listed before it succeed.

\section{The examplary proof}
\label{sec:examplary-proof-in-ltac2-mosel}

We now show what the proof looks like in the reimplemented version of MoSeL.

The full listing is in figure~\ref{fig:example-proof-mosel-ltac2}.
Since we didn't touch environment or rendering of the goals, for the user only tactics changed and everything else stayed the same, including the proof states.

Perhaps, the biggest difference from the Ltac1 version is the lack of useful notations and intropatterns.
However, this is not Ltac2's fault, but rather ours -- we didn't focus on them and this aspect can still be improved.
In particular, now we have to destruct the introduced separating conjunction with two tactic invocations: what previously was just \coqe{iIntros "[HP H]".} now becomes manual introduction of the separating conjunction \coqe{i_intro_named "HS".} and then its destruction \coqe{i_and_destruct '(INamed "HS") '(INamed "HP") '(INamed "H").}
Same goes for the existential, while previously we could destruct both the existential and disjunction in one command, now we have to perform two.

\begin{figure}
\begin{coq}
Lemma example {A : Type} (P : PROP) (Phi Psi : A â†’ PROP) :
  P * (exists a, (Phi a) \/ (Psi a)) -* exists a, (P * Phi a) \/ (P * Psi a).
Proof.
  (* iIntros "[HP H]". *)
  i_intro_named "HS".
  i_and_destruct '(INamed "HS") '(INamed "HP") '(INamed "H").
  (* iDestruct "H" as (x) "[H1|H2]". *)
  i_exist_destruct '(INamed "H") as x '(INamed "HD").
  i_or_destruct '(INamed "HD") '(INamed "H1") '(INamed "H2").
  - i_exists$\text{~}$x. i_left (). i_split_l ["HP"] ;; i_assumption ().
  - i_exists$\text{~}$x. i_right (). i_split_l ["HP"] ;; i_assumption ().
Qed.
\end{coq}
\caption{An example of a proof using Ltac2 version of MoSeL}
\label{fig:example-proof-mosel-ltac2}
\end{figure}


\section{Potential and observed improvements from translation to Ltac2}
\label{sec:impr-from-transl}

While translating implementation from Ltac1 to Ltac2, we encountered several points where Ltac2 was particularly useful.

\paragraph{Fix arities from original implementation}

In the original implementation there aren't tactics of arbitrary arity.
Instead, due to Ltac limitations, developers were forced to define several variants of tactics, each with fixed arity.

\begin{coq}
Tactic Notation "iExists" uconstr(x1) "," uconstr(x2) :=
  iExists x1; iExists x2.
Tactic Notation "iExists" uconstr(x1) "," uconstr(x2) "," uconstr(x3) :=
  iExists x1; iExists x2, x3.
$\ldots$
\end{coq}

With Ltac2 we can use scopes for lists, which allow arbitrary arities.
The example above would look as follows:

\begin{coq}
  Ltac2 Notation "iExists" lc(list1(thunk(seq(constr, with_bindings)), ",")) :=
  i_exists$\text{~}$lc.
\end{coq}

Where \coqe{i_exists} iterates over the list and applies \coqe{iExists} to each element.

\paragraph{Error messages}

Another pain point of Ltac development is lack of proper error handling.
With Ltac2 there two features that can alleviate the problem -- we can define our own custom error classes and there is a proper error handling mechanism, which allows us to match on the error thrown.

As with the \coqe{i_assumption} above, there are multiple instances of nesting tactics within each other.
One way to improve error message thrown by iAssumption would be to catch potential error thrown by \coqe{i_assumption_coq} and append it to the error message produced in \coqe{i_assumption}, so that user can see why the tactic failed.

\section{Desirable features of Ltac2}

However, there also were several features that we wished Ltac2 had and that impacted the scope of potential improvements.

\paragraph{User-defined scopes}

Perhaps, one of the useful features of the original MoSeL implementation that is missing from our implementation is intropatterns.
The proper way to define them with Ltac2 would be to extend datatype for intropattern with MoSeL-specific symbols and then parse it with a custom scope.

Unfortunately, the latter isn't currently possible without extending OCaml implementation of Ltac2, either via forking Coq or using an Ocaml plugin that modifies Ltac2 grammar.

\paragraph{User-defined pretty-printing}
Another missing feature would be lack of user-defined printing rules.
At the moment this mostly impacts error printing, since we have to rely on the Ltac2 pretty-printer, as notations are parsing-only.

\paragraph{notypeclasses refine}

Ltac2 also currently lacks a variant of \coqe{refine}, which doesn't resolve type classes on the application.
This tactic is heavily used in MoSeL development.

\paragraph{Interoperability between Ltac1 and Ltac2}

While the goal of the rewriting was to give platform for further experiments, some of the tactics were easier to import.
And while there is a way to call Ltac1 tactics from Ltac2 code, there is no proper way to pass return values there or back.
I.e.\ \href{https://gitlab.mpi-sws.org/iris/string-ident/}{iris string-ident} has to pass terms through the goal to get the result from one to another.