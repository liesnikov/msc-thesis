\chapter{Related work}
\label{cha:related-work}

One of the first advances on finding out what tactics can look like for separation logic was done by \citet{appel2006tactics}.
It built on existing work which embedded separation logic in Coq and developed a set of tactics for stepping through atomic operations, assertion operations and some automation tactics, like \coqe{sep_trivial}.
This was followed by a paper by \citet{mccreightPracticalTacticsSeparation2009}.
It presented a comprehensible set of tactics in Coq, applied them to Cminor, a C-like intermediate language for CompCert and used them to verify a garbage collector.
Afterwards, ``Charge!'' framework \cite{bengtsonCharge2012} developed language- and memory-model independent tactic language, also in Coq.
It provided automation for first-order propositions in separation logic and brought tactics closer to native tactic language of Coq.

\subsection{look at IPM/solving constraints related}

\subsection{programmable tactics}

compare with other tactic languages
Mtac2 gives stronger types to tactics, what can you say about the tactics

\subsection{Context management}
\label{sec:context-management}

\begin{itemize}
\item Harland and Pym

\subsubsection{Strategies and evar instantiation}
\label{subsubsec:strategies_and_evars}

In their paper, \citet{harlandResourceDistributionBooleanConstraints2003} propose to decouple generation of equational constraints and search for their solution.
We, on the other hand, don't generate equations at all and apply all derived unifications from generated constraints immediately.

Our approach doesn't fit any of the strategies described in the paper exactly, but is closest to the ``lazy'' strategy.

In the ``lazy'' strategy one branch is pursued till the maximum depth is reached, then constraints for the expressions are generated in form of equations.
These are provided to a solver, which outputs and assignment \(I\) for variables present in the expression and the solution is propagated to other branches.

``Eager distribution'' strategy requires exploring all branches until the very bottoms and only after that querying constraint solver with all equations.
This is the only strategy that our approach doesn't accommodate at all, since we solve constraints immediately.

Since Iris Proof Mode is accommodated by Coq, we get some flexibility for free, which isn't necessarily present in the strategies described above.
In particular, since goals in Iris Proof Mode are Coq goals too, the user can jump from one goal to another at any moment, which resembles ``intermediate'' distribution.

We also provide users with an ability to impose arbitrary constraints at any given moment.
This is useful if the constraints don't necessarily enforce presence or absence of the resource, but the user doesn't want to postpone the decision of resource distribution.
Which makes Iris Proof Mode with constraints strictly subsume regular one.
  
\item Idris \cite{MultiplicitiesIdris2Documentation}

\item Tag-based approaches \citet{hodasTagFrameSystemResource2002} \citet{lopezImplementingEfficientResource2004}
  \href{http://www-cgi.cs.cmu.edu/afs/cs/user/fp/www/courses/lp/lectures/15-resources.pdf}{pfenning lectures}
  implemented in Lolli \cite{LolliLinearLogic}
\end{itemize}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "thesis"
%%% TeX-parse-self: t
%%% TeX-auto-save: t
%%% reftex-cite-format: natbib
%%% reftex-default-bibliography: ("/home/buzzer/my-dir/ed/uni/saar/prjcts/iris/npm/tex/TacticsProofs.bib")
%%% End: