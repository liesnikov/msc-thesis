\chapter{Ltac2}

Ltac2 is a tactic language that comes as a successor to Ltac and in this chapter we give an overview of its semantics and features.
Following the convention (\cite[Section 3.3.2]{thecoqdevelopmentteamCoqProofAssistant2020} \cite{pedrotLtac2TacticalWarfare2019}) we will be calling the original implementation Ltac1.

The need for a new tactic language is well-justified due to multiple issues with Ltac1, the very first one being that it was never intended to be a full tactic language -- as per \citet{pedrotCoqHoTTminuteTickingClockwork2016}, the aim was to handle ``small automations''.
Current usages of Ltac1, i.e. Bedrock platform by \citet{chlipalaMostlyautomatedVerificationLowlevel2011} and Iris Proof Mode by \citet{krebbersInteractiveProofsHigherorder2017, krebbersMoSeLGeneralExtensible2018} go far beyond what one would consider ``simple''.
This discrepancy between intent and usage shows itself in unpredictability and lack of uniformity in semantics, absence of user-defined datatypes, as well as issues with maintainability (\cite[Section 3.3.2]{thecoqdevelopmentteamCoqProofAssistant2020} \cite{pedrotLtac2TacticalWarfare2019}).

Coq community developed multiple alternatives to Ltac1, such Mtac \cite*{zilianiMtacMonadTyped2013, kaiserMtac2TypedTactics2018a}, which is focusing on stronger types for tactics,
Rtac by \citet{malechaExtensibleEfficientAutomation2016} and Cydele by \citet{claretLightweightProofReflection2013}, providing reflection-based tactics and others.

Ltac2, on the other hand, aims not for a new approach to tactics, but rather to be a sane successor to Ltac1, being backwards-compatible where possible.
It is still experimental and was integrated in Coq in version 8.11, so the description here applies only to versions 8.11 and 8.12, which are available at the moment.

We will first cover semantics of the language and then turn to various features, such as notations and compatibility with Ltac1.
In the end we will also present a small example of a solver for first-order logic.

\section{Semantics of Ltac2}

Ltac2 is a ML-family language, which means it is a call-by-value, effectful functional language with static types and support rank-1 polymorphism and algebraic datatypes.

Effects are interpreted in a monad, which is provided by Coq's tactic engine \cite{spiwackAbstractTypeConstructing2010}.
It is also explained in a blog post by \citet{pedrotCoqHoTTminuteTickingClockwork2016} and here we will try to expand on it, explaining not only how Ltac2 interfaces the monad, but also how some user-facing tactics are implemented.

Note that we focus on the monad from user-perspective, so the types provided in ML syntax should only be seen as guidance for an Ltac2 user, and not as true to the implementation.

\subsection{Tactics form a monad}
\label{sec:monad-tactics}

When a user applies a tactic to a goal in Coq, they expect to get back a list of new goals generated.
\begin{ocaml}
type 'a tactic = goal -> goal list * a
\end{ocaml}

However, the tactic might not always succeed, so we have to amend the type to allow tactics to fail with some exception \ocamle|exn|.
\begin{ocaml}
type 'a tactic = goal -> (exn, goal list * a) sum
\end{ocaml}

This monad comes equipped with usual monad operators \ocamle{return} and \ocamle{bind}:
\begin{ocaml}
val tclReturn : 'a -> 'a tactic.
val tclBind : 'a tactic -> ('a -> 'b tactic) -> 'b tactic.
\end{ocaml}

For a user perspective, these already allow implementation of chaining of tactics and arbitrary branching inside tactics.
We can also already recover some familiar tactical, such as sequencing: \coqe{tactic1; tactic2}, which is simply a bind with constant function.
Technically we can also implement non-backtracking branching, but this would require us to rely on the type of the tactic and not primitive operations, so we postpone it till later.

There are also several primitive tactics which are provided here and don't follow from the monadic interface, such as
\begin{coqe}
goal := fun g => Right [g] g
\end{coqe}

\subsection{Backtracking monad for tactics}
\label{sec:backtr-monad-tact}

The monad described above suffices for many purposes, it doesn't allow backtracking naturally.
The usual solution in this case is to apply some variant of \ocamle{ListT} transformer.
However, the problem with ListT is well-known \cite{jones1993composing} (or, for a more approachable explanation \cite{ListTDoneRight}) -- in general it is not associative, and hence, not a monad.
Instead we take the following type:

\begin{ocaml}
type 'a elist = Node of (exn -> 'a enode)
and 'a enode = Zero of exn | Plus of 'a * 'a elist

type +'a tactic = goal * state -> (goal list * state * 'a) elist
\end{ocaml}

The type is derived from \cite{kiselyovBacktrackingInterleavingTerminating2005} and provides several primitives.
Among those, we are interested in the following three:
\begin{ocaml}
val tclZERO : exn -> 'a tactic
val tclPLUS : 'a tactic -> (exn -> 'a tactic) -> 'a tactic
type 'a case =
  | Fail of exn
  | Next of 'a * (exn -> 'a tactic)
val tclCASE : 'a tactic -> 'a case tactic
\end{ocaml}

The type signature for tactics and the interface are not the easier to grasp or to form intuition about, so we are going to show several examples on how they apply to real-world tactics.

The functions above, however, come not on their own, but with several laws that guard execution.
Below, \coqe{zero}, \coqe{plus} and \coqe{case} correspond to their respective functions and all of \coqe{t, u, f, g, e} are values.
\begin{figure}[H]
\begin{coq}
plus t zero $\equiv$ t ()
plus (fun () => zero e) f $\equiv$ f e
plus (plus t f) g $\equiv$ plus t (fun e => plus (f e) g)
\end{coq}
\caption{Equations concerning \coqe{zero} and \coqe{plus}}
\label{fig:zero_plus_eq}
\end{figure}

We can think about \coqe{plus} as \coqe{cons} constructor of the list of results.
Respectively, \coqe{zero} is a \coqe{nil} constructor, which means that the tactic couldn't return any result and thus, failed.

This also gives us an ability to recreate branching tactics with just primitive constructions.
Surprisingly, backtracking branching is easier:
\begin{coq}
tactic1 + tactic 2 := plus (tactic1) (fun _ => tactic2)
\end{coq}
It works in the following way: if \coqe{tactic1} evaluates to an exception, that is, a zero, it is discarded as per second equation of~\ref{fig:zero_plus_eq}.
If it evaluates to a list of results, they are chained with those from \coqe{tactic2}.

Both this usage and the last equation about plus~\ref{fig:zero_plus_eq} somewhat break intuition of \coqe{plus} being \coqe{cons} constructor and instead behaves more like \coqe{app} operation on lists of results.

Now let's turn to the last element of the interface -- \coqe{case}.
Intuitively, it evaluates the thunk it is given and then takes it apart, serving as a pattern-matching construction for the lists of \coqe{plus} and \coqe{zero}.
\begin{figure}[H]
\begin{coq}
case (fun () => zero e) $\equiv$ Left e
case (fun () => plus (fun () => t) f) $\equiv$ Right (t,f)
\end{coq}
\caption{Equations concerning \coqe{case}}
\label{fig:case_eq}
\end{figure}

This enables introspection of results.
In particular, we can implement a tactical, that cuts off backtracking and returns the first value, if there is any:
\begin{coq}
Ltac2 once t := match (Control.case t) with
  | Err exn => Control.zero exn
  | Val v => let (x, rr) := v in x
  end.
\end{coq}

And using \coqe{once}, we can also implement non-backtracking branching:
\begin{coq}
tactic1 ||tactic2 := once (tactic1 + tactic2).
\end{coq}

Finally, there are two laws guarding the behavior of biding with respect to \coqe{plus} and \coqe{zero}.
\begin{figure}[H]
\begin{coq}
let x := zero e in u $\equiv$ zero e
let x := plus t f in u $\equiv$ plus (fun () => let x := t in u) (fun e => let x := f e in u)
\end{coq}
\caption{Equations concerning binders}
\label{fig:let_eq}
\end{figure}

An important thing to keep in mind is that the interface above comes \emph{in addition} to the monadic interface, which means we don't have to deal with it unless backtracking is concerned.

\subsection{General language feature and other effects}
\label{sec:other-effects}

Aside from the effects described above, Ltac2 also features
\begin{itemize}
\item standard non-backtracking IO, in particular, printing and mutable arrays
\item ``fatal'' errors, which don't go through the backtracking machinery described above and can't be caught
  \begin{coq}
  Ltac2 throw : exn -> 'a
  \end{coq}\vspace{-0.7em}
\item ability to inspect goals.
  We mentioned \coqe{goal} briefly before, but user also gets access to hypothesis:
  \begin{coq}
  Ltac2 goal : unit -> constr
  Ltac2 hyp : ident -> constr.
  Ltac2 hyps : unit -> (ident * constr option * constr) list.
  \end{coq}\vspace{-0.7em}
\end{itemize}

As for the rest, Ltac2 is a fairly standard ML-family language, with usual features and intuitive syntax.
In particular, it has:
\begin{itemize}
\item static types, including algebraic datatypes, rank-1 polymorphism and several built-in types (\coqe{bool}, \coqe{int}, \coqe{string}, \coqe{constr}, \coqe{ident}).
  \begin{coq}
  Ltac2 Type rec int_list := [IntCons (int, int_list) | IntNil ].
  Ltac2 Type ('a, 'b) sum := [Left ('a) | Right ('b)].
  \end{coq}
\item functions, lambda functions and pattern-matching:
  \begin{coq}
  Ltac2 add_one (a : int) := Int.add a 1.
  Ltac2 rec all_gt_zero := fun (v : int_list) =>
    match v with
    | IntNil => true
    | IntCons h t => and (Int.gt h 0) (all_gt_zero t)
    end.
  \end{coq}
\end{itemize}

\section{Standard library for Ltac2 and differences from Ltac1}

In the previous section we described general language features, now we turn to non-essential parts of the language.

\subsection{Matching terms}
\label{sec:matching-terms}

In order to work with coq terms effectively, Ltac2 gives user an ability to match them in a way, which is very similar to matching proper Ltac2 terms.

\begin{itemize}
  \item Matching terms
  
  \item Notations and scopes
  \item Exceptions
\end{itemize}

\section{Propositional solver}
\label{sec:propositional-solver}

\begin{coq}
Ltac2 rec tauto () :=
  match! goal with
  | [|- True] =>
    refine '(I)
  | [|- ?p /\ ?q] =>
    split > [tauto ()| tauto ()]
  | [|- ?p \/ ?q] =>
    Control.plus (fun () => refine '(or_introl _); tauto ())
                 (fun e => refine '(or_intror _); tauto ())
  | [|- forall _, _] =>
    intros ?; tauto ()
  | [|- exists (_ : ?a), _] =>
    eexists; tauto ()
  | [|- _] => eassumption
  end.
\end{coq}
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "thesis"
%%% TeX-parse-self: t
%%% TeX-auto-save: t
%%% reftex-cite-format: natbib
%%% reftex-default-bibliography: ("/home/buzzer/my-dir/ed/uni/saar/prjcts/iris/npm/tex/TacticsProofs.bib")
%%% End: