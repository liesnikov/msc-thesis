\chapter{Introduction}

This thesis is about interactive proof development for separation logic.
In the introductory chapter we give an overview for history of developments of mechanized tools for separation logic, highlight some of the gaps of existing developments and list our contributions to the subject.

\section{Separation logic and mechanization}
\label{sec:separation-logic-mechanization}

Separation logic (SL) was introduced by \citet{reynoldsSeparationLogicLogic2002} and
\citet{ohearnLocalReasoningPrograms2001} as a solution to problems with reasoning about mutable data structures.
It proved to be widely successful \cite{ohearnSeparationLogic2019} and served as a basis for multiple other developments of logics used for reasoning about programs, the most influential of them, perhaps, being Concurrent Separation Logic (CSL) by \citet{ohearnResourcesConcurrencyLocal2007}.

In the last decade there were multiple new advanced logics developed that are both higher-order and based on Concurrency Separation Logic, like one that serves as a foundation for Verified Software Toolchain by \citet{appelProgramLogicsCertified2014} or Iris \cite{jungIrisGroundModular2018}, which was used to establish formal foundations of Rust programming language \cite{jungRustBeltSecuringFoundations2018}.

Separation logic also gave rise to multiple mechanized tools.
Initial applications of separation logic to mechanized developments were concentrating on mostly automatic proofs, like Smallfoot~\cite{berdineSmallfootModularAutomatic2006} or Verifast~\cite{jacobsVeriFastProgramVerifier2008} or Bedrock~\cite{chlipalaMostlyautomatedVerificationLowlevel2011, chlipalaBedrockStructuredProgramming2013}.
With this approach logics have to be restricted in order for automation to be feasible, as on its own even separation logic with a magic wand \((\wand)\) is undecidable \cite{brotherstonUndecidabilityPropositionalSeparation2014}.

However, automatic proofs are not the only possibility and they are not suitable for more expressive variants of SL, which can include advanced connectives, such as modalities and views.
The alternative to automatic verification is tactic-based interactive verification.
There are multiple developments that pursue this idea, usually utilizing existing interactive proof assistants: ``Charge!''~\cite{bengtsonCharge2012},
, VST-Floyd~\cite{caoVSTFloydSeparationLogic2018} for Verified Software Toolchain, MoSeL for Iris \cite{krebbersInteractiveProofsHigherorder2017, krebbersMoSeLGeneralExtensible2018}.
In fact, MoSeL (and its predecessor, IPM -- Iris Proof Mode) turned out to be essential for developments based on Iris \cite{krebbersMoSeLGeneralExtensible2018, jungUnderstandingEvolvingRust2020}: verification of Rust's safety claims \cite{jungRustBeltSecuringFoundations2018, jungStackedBorrowsAliasing2019, dangRustBeltMeetsRelaxed2019}, formalization of Scala's core type system \cite{giarrussoScalaStepbystepSoundness2020}, framework for concurrent reasoning based on message-passing \cite{hinrichsenActrisSessiontypeBased2019} and many others.

VST-Floyd~\cite{caoVSTFloydSeparationLogic2018} and MoSeL \cite{krebbersMoSeLGeneralExtensible2018} are two most recent major pieces of work in the direction of tactic-based interactive verification.
Both of them provide support for automation, though differ significantly in approaches.
VST-Floyd follows the idea of normal form for goals, which was also used in \cite{bengtsonCharge2012} and is focused tactics for one specific logic and forward-style reasoning approach.
MoSeL, on the other hand, doesn't try to normalize goals and places emphasis on genericity of the logic: it builds on the interface of Modal Bunched Implications (MoBI) logic, which allows user to apply it in any logic that instantiates the interface.

\section{Problems and approaches}
\label{sec:problems-approaches-intro}

While MoSeL achieved a lot, there still are some issues with the current state of the tool.
We now describe the problems and our approach to solving them in this thesis.

\subsection{Ltac1 issues}
\label{sec:ltac1-issues}
Ltac was the first tactic language for Coq that allowed extensive automation and it served Coq well, being called ``major ingredient of the success'' of Coq \cite{pedrotLtac2TacticalWarfare2019}.
Unfortunately, it has outgrown its original purpose and is now known to be a problematic for developments of non-trivial complexity.
It has badly defined semantics, such that even maintainers don't understand the order of evaluation \cite{pedrotLtacInternals2016}, it lacks clear distinction between Coq variables and Ltac variables \cite{pedrotLtacInternals2016}, proper exceptions, ability to deal with existential variables and even documentation says that some tactics should be used ``at your own risk'' \cite[Section~3.3.1]{thecoqdevelopmentteamCoqProofAssistant2020}.
MoSeL also relies on Ltac to a great extent and this used to be a handicap for its development and maintenance, because of the fragility of larger programs written in Ltac.

Fortunately, since the problem with Ltac are well-known, many other languages appeared to substitute it \cite{malechaExtensibleEfficientAutomation2016, zilianiMtacMonadTyped2013, kaiserMtac2TypedTactics2018a, tassiElpiExtensionLanguage2018}.
There is also a new experimental tactic language that aims to be a direct successor of Ltac, trying to stay as close as possible to Ltac, while maintaining sane semantics: Ltac2 \cite{pedrotLtac2TacticalWarfare2019}.

We rewrite Ltac parts of MoSeL to Ltac2, trying to improve the implementation where possible and use this new version of MoSeL to develop new features.

\subsection{\coqe{iSplit} tactic}
\label{sec:isplit-tactic}

One of the main problems with incorporating backwards-style proofs to separation logic is the introduction rule for a new connective -- ``separating conjunction''.
\[\infer{\Gamma_1, \Gamma_2 \vdash \phi_1 \ast \phi_2}
        {\Gamma_1 \vdash \phi_1 &
         \Gamma_2 \vdash \phi_2} \]
The logic is substructural since it lacks contraction rule, so introduction of separating conjunction forces us to distribute hypotheses between two branches of the proof.
However, this creates a problem with bottom-up proof construction, since we frequently don't know which propositions will be needed in which branch until it's finished.

In MoSeL, introduction of separating conjunction corresponds to \coqe{iSplit} tactic (separation logic variant of \coqe{split}).
It requires a user to provide a list of hypotheses that will be attributed to either left (\coqe{iSplitL}) or right (\coqe{iSplitR}) branch, essentially guessing beforehand which hypotheses are going to be used where.

The issue with the rule was first described in a paper by \citet{harlandResourceDistributionBooleanConstraints2003}.
They proposed an amended entailment predicate to solve the problem.
The idea is to postpone the distribution by attaching Boolean flags (\(e_1, e_2\)) that indicate presence of hypotheses and imposing a side-condition that the flags are disjoint.
\[\infer[e_i \oplus \hat{e}_i = \true, i \in \{1,2\}]
        {P, Q \vdash \phi_1 \ast \phi_2}
        {P[e_1], Q[e_2] \vdash \phi_1 &
         P[\hat{e}_1], Q[\hat{e}_2] \vdash \phi_2} \]
We adapt their solution to MoSeL and create a new \coqe{iSplit} tactic, that doesn't require the user to provide such a list.

\subsection{Goal matching}
\label{sec:goal-matching}

One of the very useful tacticals of Ltac was \coqe{match goal}.
It allows a user to match the hypothesis and the goal in the current proof state and has proven to be essential for automation tactics, i.e. it is used in \coqe{naive_solver} from stdpp~\cite{ProjectsIrisStdpp}, one of the first examples in CPDT~\cite{chlipalaCertifiedProgrammingDependent2013} and \coqe{break_match} tactic from StuctTact library~\cite{UwplseStructTact2020}.
\begin{coq}
match goal with
| [H : False |- _] => exfalso; exact H
| [|- True] => exact I
end.
\end{coq}

MoSeL doesn't use Coq contexts and instead stores hypothesis in the goal, which renders the original tactical unfit for it, and Ltac doesn't provide a way to reuse the syntax of goal matching for user-defined tactics.
We develop a new tactic \coqe{iMatch goal} in Ltac2 for reimplemented MoSeL, which aims to be a separation-logic alternative to \coqe{match goal}.
  
\section{Contributions}
\label{sec:contributions}

\begin{itemize}
\item In chapter~\ref{chap:reimplementation_ipm}, we describe reimplementaion of MoSeL in Ltac2, thus contributing one of the first significant applications of the language.
  In the process, we evaluate parts of the language used and suggest possible directions for future development.
\item In chapter~\ref{chap:postponed_splitting}, we develop and adaptation of results by \citet{harlandResourceDistributionBooleanConstraints2003} to MoSeL, as reimplemented in the previous chapter, to introduce a new splitting tactic \coqe{iSplit}.
\item In chapter~\ref{chap:imatch}, we describe a new primitive \coqe{iMatch goal} for tactic language of separation logic, which allows us to match entailments akin to Coq's native \coqe{match goal} construct.
\item Finally, in chapter~\ref{chap:solver} we bring the implemented features together in order to implement a solver for separation logic.
\end{itemize}
We conclude with an overview of related work~\ref{cha:related-work}.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "thesis"
%%% TeX-parse-self: t
%%% TeX-auto-save: t
%%% reftex-cite-format: natbib
%%% reftex-default-bibliography: ("/home/buzzer/my-dir/ed/uni/saar/prjcts/iris/npm/tex/TacticsProofs.bib")
%%% End: